#include "LocalMeasure.hpp"
#include <vector>
#include <iostream>
#include "Measure.hpp"
#include "Graph.hpp"
#include "utils.hpp"
#include "Timer.hpp"
using namespace std;

const string LocalMeasure::autogenMatricesFolder = "matrices/autogenerated/";

LocalMeasure::LocalMeasure(Graph* G1, Graph* G2, string name) : Measure(G1, G2, name) {
}

LocalMeasure::~LocalMeasure() {
}

double LocalMeasure::eval(const Alignment& A) {
	uint n = G1->getNumNodes();
	double similaritySum = 0;
	for (uint i = 0; i < n; i++) {
		similaritySum += sims[i][A[i]];
	}
    return similaritySum/n;
}

bool LocalMeasure::isLocal() {
	return true;
}

vector<vector<float> >* LocalMeasure::getSimMatrix() {
	return &sims;
}

void LocalMeasure::loadBinSimMatrix(string simMatrixFileName) {
	if (fileExists(simMatrixFileName)) {
		uint n1 = G1->getNumNodes();
		uint n2 = G2->getNumNodes();
		sims = vector<vector<float> > (n1, vector<float> (n2));
		readMatrixFromBinaryFile(sims, simMatrixFileName);
	}
	else {
		cerr << "Computing " << simMatrixFileName << " ... ";
		Timer T;
		T.start();
		initSimMatrix();
		cerr << "done (" << T.elapsedString() << ")" << endl;
		writeMatrixToBinaryFile(sims, simMatrixFileName);
	}
}

void LocalMeasure::writeSimsWithNames(string outfile) {
	map<ushort,string> mapG1 = G1->getIndexToNodeNameMap();
	map<ushort,string> mapG2 = G2->getIndexToNodeNameMap();
	uint n1 = G1->getNumNodes();
	uint n2 = G2->getNumNodes();
	ofstream fout(outfile);
	for (uint i = 0; i < n1; i++) {
		for (uint j = 0; j < n2; j++) {
			fout << mapG1[i] << " " << mapG2[j] << " " << sims[i][j] << endl;
		}
	}
}
